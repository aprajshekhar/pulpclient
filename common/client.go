// client
package common

import (
	"github.com/Azure/azure-sdk-for-go/core/http"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"github.com/Azure/azure-sdk-for-go/core/tls"
)

type Client struct{
	Endpoint    		string
	Cert				Certificate
	UserName			string //credentials to use
	Password			string //if certificate auth is not being used	
}

type Certificate struct{
	PkiCertificate		string //Certificate given back by pulp
	PkiKey				string //Key given back by pulp
}

func NewClient(endpoint, pkicert, pkikey, username, password string) *Client{
	client := &Client{
		Endpoint: endpoint,
		UserName: username,
		Password: password,
		Cert: Certificate{
			PkiCertificate:pkicert, 
			PkiKey:pkikey,
		},
	}

	return client
}

// Format of reply when http error code is not 200.
// Format may be:
// {"error": "reason"}
// {"error": {"param": "reason"}}
type requestError struct {
	Error interface{} `json:"error"` // Description of this error.
}

func (client *Client) SetEndpoint(endpoint string){
	client.Endpoint = endpoint
}

func (client *Client) SetPkiCertificate(pkicert string){
	client.Cert.PkiCertificate = pkicert
}

func (client *Client) SetPkiKey(pkikey string){
	client.Cert.PkiKey = pkikey
}

func (client *Client) SetUserName(username string){
	client.UserName = username
}

func (client *Client) SetPassword(password string){
	client.Password = password
}

func (client *Client) Authenticate() error{
	var body []byte
	var cert Certificate
	fmt.Println("endpoint: "+client.Endpoint)
	
	transport :=  &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true,
			},
    }
	defaultClient := &http.Client{Transport: transport}
	request, err := http.NewRequest("POST",client.Endpoint,nil)
	
	if err!= nil{
		return err
	}
	request.SetBasicAuth(client.UserName, client.Password)
	response, err := defaultClient.Do(request)
	
	if err!=nil{
		return err
	}
	
	defer response.Body.Close()
	
	if body, err = getResponse(response); err != nil {
		return err
	}
	fmt.Println("body")
	fmt.Println(body)
	if err = json.Unmarshal(body, &cert); err !=nil {
		return err
	}
	
	client.Cert = cert
	
	return nil
}

// Error - all errors generated by HTTP transactions are of this type.
// Other error may be passed on from library functions though.
type Error struct {
	StatusCode int // HTTP status code
	Text       string
}

// Error satisfy the error interface.
func (e *Error) Error() string {
	return e.Text
}

// newError make a new error from a string.
func newError(StatusCode int, Text string) *Error {
	return &Error{
		StatusCode: StatusCode,
		Text:       Text,
	}
}

// newErrorf makes a new error from sprintf parameters.
func newErrorf(StatusCode int, Text string, Parameters ...interface{}) *Error {
	return newError(StatusCode, fmt.Sprintf(Text, Parameters...))
}

func getResponse(r *http.Response) ([]byte, error) {
	var e requestError
	var b []byte
	var err error

	if b, err = ioutil.ReadAll(r.Body); err != nil {
		return nil, err
	}
	if r.StatusCode == http.StatusOK {
		return b, nil
	}
	if err = json.Unmarshal(b, &e); err == nil {
		switch v := e.Error.(type) {
		case string:
			return nil, newErrorf(r.StatusCode, "%s", v)
		case map[string]interface{}:
			for param, reason := range v {
				if reasonstr, ok := reason.(string); ok {
					return nil, newErrorf(r.StatusCode, "%s: %s", param, reasonstr)
				}
			}
			return nil, newErrorf(r.StatusCode, "wrong parameter")
		}
	}
	return nil, newErrorf(r.StatusCode, "unexpected HTTP status code %d", r.StatusCode)
}